from abc import ABCMeta, abstractmethod, abstractproperty
from typing import Any, Callable, List, Optional, Tuple

from ansible.playbook.play_context import PlayContext
BUFSIZE = ... # type: int

def ensure_connect(func: Callable) -> Callable: ...

class ConnectionBase:
    has_pipelining = ... # type: bool
    has_native_async = ... # type: bool
    always_pipeline_modules = ... # type: bool
    become_methods = ... # type: List[str]
    module_implementation_preferences = ... # type: Tuple[str]
    allow_executable = ... # type: bool
    _play_context = ... # type: PlayContext
    _new_stdin = ... # type: Any
    _display = ... # type: Callable
    _connected = ... # type: bool

    def __init__(self, play_context: PlayContext, new_stdin: Any, *args: object, **kwargs: object) -> None: ...
    @property
    def connected(self) -> bool: ...
    def _become_method_supported(self) -> bool: ...
    def set_host_overrides(self, host: str, hostvars: dict = ...) -> None: ...
    @staticmethod
    def _split_ssh_args(argstring: str) -> List[str]: ...
    @abstractproperty
    def transport(self) -> str: ...
    @abstractmethod
    def _connect(self) -> None: ...
    @ensure_connect
    @abstractmethod
    def exec_command(self, cmd: bytes, in_data: Optional[file] = ..., sudoable: bool = ...) -> Tuple[int, bytes, bytes]: ...
    @ensure_connect
    @abstractmethod
    def put_file(self, in_path: str, out_path: str) -> None: ...
    @ensure_connect
    @abstractmethod
    def fetch_file(self, in_path: str, out_path: str) -> None: ...
    @abstractmethod
    def close(self) -> None: ...
    def check_become_success(self, b_output: bytes) -> bool: ...
    def check_password_prompt(self, b_output: bytes) -> bool: ...
    def check_incorrect_password(self, b_output: bytes) -> bool: ...
    def check_missing_password(self, b_output: bytes) -> bool: ...
    def connection_lock(self) -> None: ...
    def connection_unlock(self) -> None: ...
    def reset(self) -> None: ...
